//! The parser parses the tokens created by the lexer and and builds an abstract syntax tree
//! from them.
//!
use crate::ast;
use crate::ast::{AST, BinaryOperator};
use crate::error::{ParsingError, ParsingErrorKind};
use crate::lexer::Lexer;
use crate::position_container::{PositionRange, PositionRangeContainer};
use crate::token::{Token, TokenType};

/// A parser of tokens generated by its [Lexer].
pub(crate) struct Parser<R: Iterator<Item=String>> {
    /// The [Lexer] to read the [Token]s from.
    lexer: Lexer<R>,
    /// The current token of the parser.
    current_token: Result<Option<Token>, ParsingError>,
    previous_position: PositionRange,
}

/// The result of a parsing method.
type ParseResult = Result<Box<AST>, ParsingError>;

impl<R: Iterator<Item=String>> Parser<R> {
    /// Creates a new Parser with the lexer.
    pub(crate) fn new(lexer: Lexer<R>) -> Self {
        Self {
            lexer,
            current_token: Ok(None),
            previous_position: PositionRange {
                line: 0,
                column: 0..=0,
            },
        }
    }

    /// Reads the next token from self.lexer, writes it into self.current_token and returns it.
    fn get_next_token(&mut self) -> &Result<Option<Token>, ParsingError> {
        // Update previous position if possible
        if let Ok(Some(tok)) = &self.current_token {
            self.previous_position = tok.position.clone()
        }
        // Load next token
        self.current_token = self.lexer.next().transpose();
        &self.current_token
    }

    /// Parses a binary expression, potentially followed by a sequence of (binary operator, primary expression).
    ///
    /// Note: Parentheses are a primary expression, so we don't have to worry about them here.
    fn parse_binary_expression(&mut self) -> ParseResult {
        let lhs = match self.parse_primary_expression() {
            Some(lhs) => lhs?,
            None => return Err(ParsingError{
                kind: ParsingErrorKind::ExpectedExpression,
                msg: format!("Expected binary expression, got {:?} instead", self.current_token),
                position: self.current_position()
            }),
        };
        self.parse_binary_operation_rhs(None, lhs)
    }

    /// Parses a sequence of `(binary operation, primary expression)`. If this sequence is empty, it returns `lhs`.
    /// This function does not consume any tokens, if the binary operator has less precedence than [self.min_operator].
    ///
    /// # Examples
    ///
    /// Think of the following expression: `a + b * c`. Then [self.lhs] contains `a`. This function reads the
    /// operator `+` and gets its precedence. Now the function parses the following primary expression as rhs, so
    /// here `b`. Then current_token contains `*`. This has a higher precedence than `+`, so the function recursively
    /// calls itself and parses everything on the right side until an operator is found, which precedence is not
    /// higher than `+`.
    fn parse_binary_operation_rhs(&mut self, min_operator: Option<BinaryOperator>,
                                  lhs: Box<AST>) -> ParseResult {
        let mut lhs = lhs;
        loop {
            // Read the operator
            let operator = match self.current_token.as_ref()? {
                // Expression ended here
                Some(Token{data: TokenType::Semicolon, .. }) => return Ok(lhs),
                Some(tok) => ast::BinaryOperator::from_token(tok),
                // Expression ended here
                _ => return Ok(lhs),
            };
            let operator = match operator {
                Some(op) => op,
                // Expression ended here
                None => return Ok(lhs),
            };
            if operator_banned(&operator, &min_operator) {
                return Ok(lhs);
            }

            // Consume binary operator
            self.get_next_token();

            // Parse the primary expression after the binary operator as rhs
            let mut rhs = match self.parse_primary_expression() {
                Some(rhs) => rhs?,
                None => return Ok(lhs),
            };

            // Inspect next binary operator
            match self.current_token.as_ref()? {
                Some(tok) => {
                    let next_bin_op = ast::BinaryOperator::from_token(tok);
                    if operator_banned(&operator, &next_bin_op) {
                        // The next binary operator binds stronger with rhs than with current, so let
                        // it go with rhs.
                        rhs = self.parse_binary_operation_rhs(Some(operator.clone()), rhs)?;
                    }
                },
                None => (),
            };

            // Merge lhs and rhs and continue parsing
            lhs = Box::new(AST::BinaryExpression(ast::BinaryExpression {lhs, operator: operator.clone(), rhs }));
        }
    }

    fn parse_function_prototype(&mut self) -> Result<ast::FunctionPrototype, ParsingError> {
        let func_name = match self.current_token.as_ref()? {
            Some(Token { data: TokenType::Identifier(ident), position: pos }) => {
                PositionRangeContainer { data: ident.clone(), position: pos.clone() }
            }
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected identifier for function prototype"),
                position: self.current_position(),
            }),
        };

        match self.get_next_token().as_ref()? {
            Some(Token { data: TokenType::OpeningParentheses, .. }) => (),
            other @ _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `(` in function prototype, but was {:?}", other),
                position: self.current_position(),
            })
        }

        // Read the list of arguments
        let mut arg_names = Vec::new();
        loop {
            match self.get_next_token().as_ref()? {
                Some(Token { data: TokenType::Identifier(arg_name), position }) => {
                    arg_names.push(PositionRangeContainer {
                        data: arg_name.clone(),
                        position: position.clone(),
                    });
                }
                _ => break,
            }
        }

        match &self.current_token.as_ref()? {
            Some(Token { data: TokenType::ClosingParentheses, .. }) => (),
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `)` in function prototype, got {:?} instead", self.current_token),
                position: self.current_position(),
            })
        }

        self.get_next_token();
        Ok(ast::FunctionPrototype {
            name: func_name,
            args: arg_names,
        })
    }

    fn parse_function_definition(&mut self) -> ParseResult {
        self.get_next_token();
        let func_proto = self.parse_function_prototype()?;
        let expr = self.parse_binary_expression()?;
        return Ok(Box::new(AST::Function(ast::Function {
            prototype: func_proto,
            body: expr,
        })));
    }

    /// Parses a number.
    fn parse_number(&mut self, number: PositionRangeContainer<f64>) -> ParseResult {
        let number = Ok(Box::new(AST::Number(number)));
        self.get_next_token(); // Eat number
        number
    }

    /// Parses a parentheses expression, like `(4 + 5)`.
    fn parse_parentheses(&mut self) -> ParseResult {
        self.get_next_token(); // Eat (
        let inner_expression = self.parse_binary_expression()?;
        match self.current_token.as_ref()? {
            Some(Token { data: TokenType::ClosingParentheses, .. }) => (), // Ok,
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `)`"),
                position: self.current_position(),
            }),
        }
        self.get_next_token(); // Eat )
        return Ok(inner_expression);
    }

    /// Parses a variable.
    fn parse_variable(&mut self, variable: PositionRangeContainer<String>) -> ParseResult {
        Ok(Box::new(AST::Variable(variable)))
    }

    /// Collects the arguments of a function call, like `add(arg1, arg2)`.
    fn collect_function_call_arguments(&mut self) -> Result<Vec<Box<AST>>, ParsingError> {
        if let Some(Token { data: TokenType::ClosingParentheses, .. }) = self.current_token.as_ref()? {
            // No arguments were passed
            return Ok(Vec::new());
        }
        let mut args = Vec::new();
        loop {
            args.push(self.parse_binary_expression()?);
            match self.current_token.as_ref()? {
                Some(Token { data: TokenType::ClosingParentheses, .. }) => {
                    // End of argument list
                    break;
                }
                Some(Token { data: TokenType::Comma, .. }) => {
                    // Ok, the argument list keeps going
                    ()
                }
                _ => {
                    // Illegal token
                    return Err(ParsingError {
                        kind: ParsingErrorKind::ExpectedSymbol,
                        msg: format!("Expected `)` or `,` in argument list"),
                        position: self.current_position(),
                    });
                }
            };
        };
        Ok(args)
    }

    fn parse_extern_function(&mut self) -> ParseResult {
        self.get_next_token(); // Consume extern token
        Ok(Box::new(AST::FunctionPrototype(self.parse_function_prototype()?)))
    }

    fn parse_top_level_expression(&mut self) -> ParseResult {
        let expression = self.parse_binary_expression()?;
        let function_proto = ast::FunctionPrototype {
            name: PositionRangeContainer {
                data: format!("__anonymous_function_{}", self.current_position().line),
                position: self.current_position(),
            },
            args: vec![],
        };
        Ok(Box::new(AST::Function(ast::Function { prototype: function_proto, body: expression })))
    }

    /// Parses a function call expression, like `add(2, 3)`.
    fn parse_function_call(&mut self, name: PositionRangeContainer<String>) -> ParseResult {
        self.get_next_token(); // Consume (
        let args = self.collect_function_call_arguments()?;
        self.get_next_token(); // Consume )
        Ok(Box::new(AST::FunctionCall(ast::FunctionCall { name, args })))
    }

    /// Parses an identifier. The output is either a [AST::FunctionCall] or an [AST::Variable].
    fn parse_identifier(&mut self, identifier: PositionRangeContainer<String>) -> ParseResult {
        match self.get_next_token().as_ref()? {
            Some(Token { data: TokenType::OpeningParentheses, .. }) => {
                self.parse_function_call(identifier)
            }
            _ => self.parse_variable(identifier),
        }
    }

    /// The most basic type of an expression. Primary expression are either of type identifier, number or parentheses.
    fn parse_primary_expression(&mut self) -> Option<ParseResult> {
        let current_token = match &self.current_token {
            Ok(Some(tok)) => tok,
            Err(err) => return Some(Err(err.clone())),
            Ok(None) => return None,
        };
        match current_token.clone() {
            Token { data: TokenType::Identifier(ident), position } => {
                Some(self.parse_identifier(PositionRangeContainer { data: ident, position }))
            }
            Token { data: TokenType::Number(number), position } => {
                Some(self.parse_number(PositionRangeContainer { data: number, position }))
            }
            Token { data: TokenType::OpeningParentheses, .. } => {
                Some(self.parse_parentheses())
            },
            Token{data: TokenType::Semicolon, ..} => {
                None
            }
            _ => Some(Err(ParsingError {
                kind: ParsingErrorKind::ExpectedExpression,
                msg: format!("Expected primary expression, got {:?} instead", self.current_token),
                position: self.current_position(),
            })),
        }
    }

    /// Returns the current position if available, or the last known position.
    fn current_position(&self) -> PositionRange {
        self.current_token.as_ref().ok()
            .and_then(|opt_tok| opt_tok.as_ref().and_then(|tok| Some(tok.position.clone())))
            .unwrap_or(self.previous_position.clone())
    }
}

impl<R: Iterator<Item=String>> Iterator for Parser<R> {
    type Item = ParseResult;

    fn next(&mut self) -> Option<Self::Item> {
        let token = match &self.get_next_token() {
            Ok(None) => return None, // Lexer drained
            Ok(Some(tok)) => tok,
            Err(err) => return Some(Err(err.clone())),
        };
        match token {
            Token{data: TokenType::Def, .. } => Some(self.parse_function_definition()),
            Token{data: TokenType::Extern, .. } => Some(self.parse_extern_function()),
            Token{data: TokenType::Semicolon, .. } => {
                // No_op (No operation)
                self.get_next_token();
                self.next()
            },
            _ => Some(self.parse_top_level_expression()),
        }
    }
}

fn operator_banned(operator: &ast::BinaryOperator, min_operator: &Option<ast::BinaryOperator>) -> bool {
    let min_operator = match min_operator {
        // No min_operator present. Then any operator is allowed.
        None => return false,
        Some(min_operator) => min_operator,
    };
    let operator_prec = match operator.precedence() {
        // operator isn't a binary operator. Then he is disqualified.
        None => return true,
        Some(prec) => prec,
    };
    let min_operator_prec = match min_operator.precedence() {
        // min_operator isn't a binary operator. Then any operator is allowed.
        None => return false,
        Some(prec) => prec,
    };
    operator_prec < min_operator_prec
}