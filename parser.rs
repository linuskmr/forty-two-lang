//! The parser parses the tokens created by the lexer and and builds an abstract syntax tree
//! from them.
//!
use crate::ast;
use crate::ast::AST;
use crate::error::{ParsingError, ParsingErrorKind};
use crate::lexer::Lexer;
use crate::position_container::{PositionRange, PositionRangeContainer};
use crate::token::{Token, TokenType};

/// A parser of tokens generated by its [Lexer].
pub(crate) struct Parser<R: Iterator<Item=String>> {
    /// The [Lexer] to read the [Token]s from.
    lexer: Lexer<R>,
    /// The current token of the parser.
    current_token: Result<Option<Token>, ParsingError>,
    previous_position: PositionRange,
}

/// The result of a parsing method.
type ParseResult = Result<Box<AST>, ParsingError>;

impl<R: Iterator<Item=String>> Parser<R> {
    /// Creates a new Parser with the lexer.
    pub(crate) fn new(lexer: Lexer<R>) -> Self {
        Self {
            lexer,
            current_token: Ok(None),
            previous_position: PositionRange {
                line: 0,
                column: 0..=0,
            },
        }
    }

    /// Reads the next token from self.lexer, writes it into self.current_token and returns it.
    fn get_next_token(&mut self) -> &Result<Option<Token>, ParsingError> {
        // Update previous position if possible
        if let Ok(Some(tok)) = &self.current_token {
            self.previous_position = tok.position.clone()
        }
        // Load next token
        self.current_token = self.lexer.next().transpose();
        &self.current_token
    }

    /// Parses a binary expression, potentially followed by a sequence
    /// of (binary operator, primary expression).
    ///
    /// Note: Parentheses are a primary expression, so we don't have to worry about them here.
    fn parse_expression(&mut self) -> ParseResult {
        let lhs = self.parse_primary_expression()?;
        self.parse_binary_operation_rhs(None, lhs)
    }

    /// Parses a sequence of `(binary operation, primary expression)`. If this sequence is empty,
    /// it returns `lhs`. This function does not consume any tokens, if the binary operator has
    /// less precedence than [min_operator].
    ///
    /// # Examples
    ///
    /// Think of the following expression: `a + b * c`. Then [lhs] contains `a`. This function
    /// reads the operator `+` and gets its precedence. Now the function parses the following
    /// primary expression as rhs, so here `b`. Then current_token contains `*`. This has a
    /// higher precedence than `+`, so the function recursively calls itself and parses
    /// everything on the right side until an operator is found, which precedence is not higher
    /// than `+`.
    fn parse_binary_operation_rhs(&mut self, min_operator: Option<Token>,
                                  lhs: Box<AST>) -> ParseResult {
        let mut lhs = lhs;
        loop {
            // Read the operator
            let operator = match self.current_token.as_ref()?.clone() {
                Some(tok) => tok,
                // Expression ended here
                _ => return Ok(lhs),
            };
            if operator_banned(&operator, &min_operator) {
                return Ok(lhs);
            }

            // Consume binary operator
            self.get_next_token();

            // Parse the primary expression after the binary operator as rhs
            let mut rhs = self.parse_primary_expression()?;

            let next_operator = self.current_token.as_ref()?.clone();

            // Inspect next binary operator
            if operator_banned(&operator, &next_operator) {
                // The next binary operator binds stronger with rhs than with current, so let
                // it go with rhs.
                rhs = self.parse_binary_operation_rhs(Some(operator.clone()), rhs)?;
            }

            // Merge lhs and rhs and continue parsing
            lhs = Box::new(AST::BinaryExpression { lhs, operator: operator.clone(), rhs });
        }
    }

    fn parse_function_prototype(&mut self) -> Result<ast::FunctionPrototype, ParsingError> {
        let func_name = match self.current_token.as_ref()? {
            Some(Token { data: TokenType::Identifier(ident), position: pos }) => {
                PositionRangeContainer { data: ident.clone(), position: pos.clone() }
            }
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected identifier for function prototype"),
                position: self.current_position(),
            }),
        };

        match self.get_next_token().as_ref()? {
            Some(Token { data: TokenType::OpeningParentheses, .. }) => (),
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `(` in function prototype"),
                position: self.current_position(),
            })
        }

        // Read the list of arguments
        let mut arg_names = Vec::new();
        loop {
            match self.get_next_token().as_ref()? {
                Some(Token { data: TokenType::Identifier(arg_name), position: position }) => {
                    arg_names.push(PositionRangeContainer {
                        data: arg_name.clone(),
                        position: position.clone(),
                    });
                }
                _ => break,
            }
        }

        match &self.current_token.as_ref()? {
            Some(Token { data: TokenType::ClosingParentheses, .. }) => (),
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `)` in function prototype"),
                position: self.current_position(),
            })
        }

        self.get_next_token();
        Ok(ast::FunctionPrototype {
            name: func_name,
            args: arg_names,
        })
    }

    fn parse_function_definition(&mut self) -> ParseResult {
        self.get_next_token();
        let func_proto = self.parse_function_prototype()?;
        let expr = self.parse_expression()?;
        return Ok(Box::new(AST::Function {
            prototype: func_proto,
            body: expr,
        }));
    }

    /// Parses a number.
    fn parse_number(&mut self, number: PositionRangeContainer<f64>) -> ParseResult {
        Ok(Box::new(AST::Number(number)))
    }

    /// Parses a parentheses expression, like `(4 + 5)`.
    fn parse_parentheses(&mut self) -> ParseResult {
        self.get_next_token(); // Eat (
        let inner_expression = self.parse_expression()?;
        match self.current_token.as_ref()? {
            Some(Token { data: TokenType::ClosingParentheses, .. }) => (), // Ok,
            _ => return Err(ParsingError {
                kind: ParsingErrorKind::ExpectedSymbol,
                msg: format!("Expected `)`"),
                position: self.current_position(),
            }),
        }
        self.get_next_token(); // Eat )
        return Ok(inner_expression);
    }

    /// Parses a variable.
    fn parse_variable(&mut self, variable: PositionRangeContainer<String>) -> ParseResult {
        Ok(Box::new(AST::Variable(variable)))
    }

    /// Collects the arguments of a function call, like `add(arg1, arg2)`.
    fn collect_function_call_arguments(&mut self) -> Result<Vec<Box<AST>>, ParsingError> {
        if let Some(Token { data: TokenType::ClosingParentheses, .. }) = self.current_token.as_ref()? {
            // No arguments were passed
            return Ok(Vec::new());
        }
        let mut args = Vec::new();
        loop {
            args.push(self.parse_expression()?);
            match self.current_token.as_ref()? {
                Some(Token { data: TokenType::ClosingParentheses, .. }) => {
                    // End of argument list
                    break;
                }
                Some(Token { data: TokenType::Komma, .. }) => {
                    // Ok, the argument list keeps going
                    ()
                }
                _ => {
                    // Illegal token
                    return Err(ParsingError {
                        kind: ParsingErrorKind::ExpectedSymbol,
                        msg: format!("Expected `)` or `,` in argument list"),
                        position: self.current_position(),
                    });
                }
            };
        };
        Ok(args)
    }

    /// Parses a function call expression, like `add(2, 3)`.
    fn parse_function_call(&mut self, name: PositionRangeContainer<String>) -> ParseResult {
        self.get_next_token(); // Consume (
        let args = self.collect_function_call_arguments()?;
        self.get_next_token(); // Consume )
        Ok(Box::new(AST::FunctionCall { name, args }))
    }

    /// Parses an identifier. The output is either a [ast::FunctionCall] or an [ast::Variable].
    fn parse_identifier(&mut self, identifier: PositionRangeContainer<String>) -> ParseResult {
        match self.get_next_token().as_ref()? {
            Some(Token { data: TokenType::OpeningParentheses, .. }) => {
                self.parse_function_call(identifier)
            }
            _ => self.parse_variable(identifier),
        }
    }

    /// TODO: Why is this called *primary*?
    /// Primary expression are either of type identifier, number or parentheses.
    fn parse_primary_expression(&mut self) -> ParseResult {
        match self.current_token.as_ref()?.clone() {
            Some(Token { data: TokenType::Identifier(ident), position: pos }) => {
                self.parse_identifier(PositionRangeContainer { data: ident, position: pos })
            }
            Some(Token { data: TokenType::Number(number), position }) => {
                self.parse_number(PositionRangeContainer { data: number, position })
            }
            Some(Token { data: TokenType::ClosingParentheses, .. }) => {
                self.parse_parentheses()
            }
            _ => Err(ParsingError {
                kind: ParsingErrorKind::ExpectedExpression,
                msg: format!("Expected (primary) expression"),
                position: self.current_position(),
            }),
        }
    }

    /// Returns the current position if available, or the last known position.
    fn current_position(&self) -> PositionRange {
        self.current_token.as_ref().ok()
            .and_then(|opt_tok| opt_tok.as_ref().and_then(|tok| Some(tok.position.clone())))
            .unwrap_or(self.previous_position.clone())
    }
}

impl<R: Iterator<Item=String>> Iterator for Parser<R> {
    type Item = ParseResult;

    fn next(&mut self) -> Option<Self::Item> {
        self.parse_expression()
    }
}

fn operator_banned(operator: &Token, min_operator: &Option<Token>) -> bool {
    let min_operator = match min_operator {
        // No min_operator present. Then any operator is allowed.
        None => return false,
        Some(min_operator) => min_operator,
    };
    let operator_prec = match operator.precedence() {
        // operator isn't a binary operator. Then he is disqualified.
        None => return true,
        Some(prec) => prec,
    };
    let min_operator_prec = match min_operator.precedence() {
        // min_operator isn't a binary operator. Then any operator is allowed.
        None => return false,
        Some(prec) => prec,
    };
    operator_prec < min_operator_prec
}