//! The parser parses the tokens created by the lexer and and builds an abstract syntax tree
//! from them.

use crate::ast;
use crate::ast::{AstNode, BinaryOperator, BasicDataTypeKind, Expression, BinaryExpression};
use crate::error::{FTLError, FTLErrorKind, ParseResult};
use crate::position_container::{PositionRange, PositionRangeContainer, PositionContainer};
use crate::token::{Token, TokenKind};
use std::iter::Peekable;
use std::convert::TryFrom;
use std::cmp::min;
use std::ops::Not;

/// A parser of tokens generated by its [Lexer].
pub struct Parser<TokenIter: Iterator<Item=Token>> {
    /// The source to read the [Token]s from.
    tokens: Peekable<TokenIter>,
}

impl<TokenIter: Iterator<Item=Token>> Parser<TokenIter> {
    /// Creates a new Parser from the given token iterator.
    pub fn new(tokens: TokenIter) -> Self {
        Self { tokens: tokens.peekable() }
    }

    /// Returns the position of the current token or [PositionRange::default()] if self.tokens.peek() returns None.
    fn current_position(&mut self) -> PositionRange {
        self.tokens.peek()
            .map(|token| token.position)
            .unwrap_or_default()
    }

    /// Parses a binary expression, potentially followed by a sequence of (binary operator, primary expression).
    ///
    /// Note: Parentheses are a primary expression, so we don't have to worry about them here.
    fn parse_binary_expression(&mut self) -> ParseResult<Expression> {
        let lhs: Expression = self.parse_primary_expression()?;
        self.parse_binary_operation_rhs(None, lhs)
    }

    /// Parses a sequence of `(binary operator, primary expression)`. If this sequence is empty, it returns `lhs`. If
    /// the binary operator has less precedence than `min_operator`.
    ///
    /// # Examples
    ///
    /// Think of the following expression: `a + b * c`. Then `lhs` contains `a`. This function reads the
    /// operator `+` and parses the following expression as `rhs`, so `b` here. Than `next_operator` is read and
    /// contains `*`. Because [BinaryOperator::Multiplication] (`*`) has a higher precedence than
    /// [BinaryOperator::Addition] (`+`). This causes this function recursively
    /// calls itself and parses everything on the right side until an operator is found, which precedence is not
    /// higher than `+`.
    fn parse_binary_operation_rhs(
        &mut self, min_operator: Option<&BinaryOperator>, lhs: Expression
    ) -> ParseResult<Expression> {
        // Make lhs mutable without enforcing the function caller that its lhs must be mutable
        let mut lhs = lhs;
        loop {
            // Read the operator after lhs and before rhs. On Err(...), return the error
            let operator = match self.parse_operator(min_operator, true)? {
                // Found an operator
                Some(operator) => operator,
                // Expression ended here
                None => return Ok(lhs),
            };
            // Parse the primary expression after operator as rhs
            let mut rhs: Expression = self.parse_primary_expression()?;
            // Inspect next operator
            self.parse_operator(min_operator, false).map(|next_operator|
                // If `next_operator` binds stronger with `rhs` than the current `operator`, let `rhs` go with
                // `next_operator`
                if next_operator > operator {
                    rhs = self.parse_binary_operation_rhs(Some(&operator.data), rhs)?;
                }
            )?;
            // Merge lhs and rhs and continue parsing
            lhs = Expression::BinaryExpression(BinaryExpression{
                lhs: Box::new(lhs),
                operator,
                rhs: Box::new(rhs)
            });
        }
    }

    /// Parses the next [BinaryOperator] from [Lexer::tokens]. Returns the [BinaryOperator] if it has more precedence than
    /// `min_operator`, otherwise [None]. If [Lexer::tokens] doesn't yield a [BinaryOperator], an [Err] is returned.
    ///
    /// # Arguments
    ///
    /// * `min_operator` - The parsed operator has to be greater than this minimum threshold. If [None], accept all
    /// operators.
    /// * `consume` - True if you want that the operator gets consumed, i.e. [Lexer::tokens.next()] will not yield the
    /// operator, but the token after the operator. False if you want that the operator don't gets consumed, i.e.
    /// [Lexer::tokens.next()] will yield the operator.
    fn parse_operator(
        &mut self, min_operator: Option<&BinaryOperator>, consume: bool
    ) -> ParseResult<Option<PositionRangeContainer<BinaryOperator>>> {
        // Read the operator
        let operator = match self.tokens.peek() {
            // No operator
            Some(Token{data: TokenKind::EndOfLine, .. }) | None => return Ok(None),
            Some(token) => PositionRangeContainer::<BinaryOperator>::try_from(token)?,
        };
        // Consume operator
        if consume { self.tokens.next(); }
        Ok(match min_operator {
            // min_operator not set. Accept every operator
            None => Some(operator),
            // Do not take operator with less or equal precedence compared to min_operator
            Some(min_op) => if operator > min_op { Some(operator) } else { None },
        })
    }

    fn parse_function_prototype(&mut self) -> ParseResult<ast::FunctionPrototype> {
        // Get and consume function name
        let function_name = match self.tokens.next() {
            Some(Token { data: TokenKind::Identifier(identifier), position: pos }) => {
                PositionRangeContainer { data: identifier.clone(), position: pos.clone() }
            }
            other => return Err(FTLError {
                kind: FTLErrorKind::IllegalToken,
                msg: format!("Expected identifier for function prototype, got {:?}", other),
                position: self.current_position(),
            }),
        };
        // Check and consume opening parentheses
        match self.tokens.next() {
            Some(Token { data: TokenKind::OpeningParentheses, .. }) => (),
            other => return Err(FTLError {
                kind: FTLErrorKind::IllegalSymbol,
                msg: format!("Expected `(` in function prototype, got {:?}", other),
                position: self.current_position(),
            })
        }
        // Read list of arguments
        let mut arguments= self.parse_argument_list()?;
        // Check and consume closing parentheses
        match self.tokens.next() {
            Some(Token { data: TokenKind::ClosingParentheses, .. }) => (),
            other => return Err(FTLError {
                kind: FTLErrorKind::IllegalSymbol,
                msg: format!("Expected `)` in function prototype, got {:?}", other),
                position: self.current_position(),
            })
        }
        Ok(ast::FunctionPrototype { name: function_name, args: arguments })
    }

    /// Pareses a list of arguments seperated by comma, i.e. `name: type` like `answer: int`. This function parses
    /// arguments as long as they start with an identifier, so e.g. when reading a TokenType::ClosingParentheses, the
    /// parsing of arguments stops.
    fn parse_argument_list(&mut self) -> ParseResult<Vec<ast::FunctionArgument>> {
        let mut arguments = Vec::new();
        // Check if argument list starts with identifier. If not, the argument list is finished
        if let Some(Token {data: TokenKind::Identifier(_), ..}) = self.tokens.peek() {} else { return Ok(arguments) }
        // Collect all arguments
        loop {
            // Get and consume argument name
            let argument_name = match self.tokens.next() {
                Some(Token {data: TokenKind::Identifier(data), position}) => {
                    PositionRangeContainer {data: data.clone(), position: position.clone()}
                }
                other => return Err(FTLError {
                    kind: FTLErrorKind::IllegalToken,
                    msg: format!("Expected argument name, got {:?}", other),
                    position: self.current_position()
                })
            };
            // Check and consume colon
            match self.tokens.next() {
                Some(Token {data: TokenKind::Colon, ..}) => (),
                other => return Err(FTLError {
                    kind: FTLErrorKind::IllegalToken,
                    msg: format!("Expected `:`, got {:?}", other),
                    position: self.current_position()
                })
            };
            // Get and consume argument type
            let argument_type = self.parse_type()?;
            // Check and consume comma
            match self.tokens.peek() {
                Some(Token {data: TokenKind::Comma, ..}) => self.tokens.next(),
                _ => break // No comma after this argument means this is the last argument
            };
            arguments.push(ast::FunctionArgument { name: argument_name, typ: argument_type });
        }
        Ok(arguments)
    }

    /// Parses a data type. A data type is either
    ///
    /// * a basic data type (like `int` or `float`),
    /// * a pointer to a data type (like `ptr int`),
    /// * a user defined data type, e.g. a `struct`.
    fn parse_type(&mut self) -> ParseResult<ast::DataType> {
        match self.tokens.next() {
            Some(Token {data: TokenKind::Identifier(typeStr), position}) if typeStr == "ptr" => {
                // Pointer
                let pointer_to_type = self.parse_type()?;
                Ok(ast::DataType {
                    data: pointer_to_type.data,
                    position: PositionRange {
                        line: position.line,
                        column: *position.column.start()..=*pointer_to_type.position.column.end()
                    }
                })
            }
            Some(Token {data: TokenKind::Identifier(typeStr), position}) => {
                if let Ok(basic_data_type) = BasicDataTypeKind::try_from(typeStr.as_str()) {
                    // Basic data type
                    Ok(ast::DataType { data: ast::DataTypeKind::Basic(basic_data_type), position })
                } else {
                    // User defined data type / struct
                    Ok(ast::DataType { data: ast::DataTypeKind::Struct(typeStr), position })
                }
            }
            other => Err(FTLError {
                kind: FTLErrorKind::IllegalToken,
                msg: format!("Expected argument type, got {:?}", other),
                position: self.current_position()
            })
        }
    }

    fn parse_function_definition(&mut self) -> ParseResult<ast::Function> {
        let function_prototype = self.parse_function_prototype()?;
        let body = self.parse_binary_expression()?;
        return Ok(ast::Function { prototype: function_prototype, body });
    }

    /// Parses a number.
    fn parse_number(&mut self) -> ParseResult<ast::Number> {
        Ok(match self.tokens.next() {
            Some(Token {data: TokenKind::Number(number), position}) => {
                ast::Number { data: number, position }
            },
            _ => panic!("parse_number() expected number token"),
        })
    }

    /// Parses a parentheses expression, like `(4 + 5)`.
    fn parse_parentheses(&mut self) -> ParseResult<ast::BinaryExpression> {
        assert_eq!(self.tokens.next().map(|token| token.data), Some(TokenKind::OpeningParentheses));
        let inner_expression = self.parse_binary_expression()?;
        match self.tokens.next() {
            Some(Token { data: TokenKind::ClosingParentheses, .. }) => (), // Ok,
            other => return Err(FTLError {
                kind: FTLErrorKind::IllegalSymbol,
                msg: format!("Expected `)`, got {:?}", other),
                position: self.current_position(),
            }),
        }
        return Ok(inner_expression);
    }

    /// Parses a variable.
    fn parse_variable(&mut self, identifier: PositionRangeContainer<String>) -> ParseResult<ast::Variable> {
        assert!(!identifier.data.is_empty());
        Ok(ast::Variable {data: identifier.data, position: identifier.position})
    }

    fn parse_extern_function(&mut self) -> ParseResult<ast::FunctionPrototype> {
        assert_eq!(self.tokens.next().map(|token| token.data), Some(TokenKind::Identifier(String::from("extern"))));
        self.parse_function_prototype()
    }

    fn parse_top_level_expression(&mut self) -> ParseResult<ast::Function> {
        let expression = self.parse_binary_expression()?;
        let function_prototype = ast::FunctionPrototype {
            name: PositionRangeContainer {
                data: format!("__anonymous_function_L{}", self.current_position().line),
                position: self.current_position(),
            },
            args: Vec::new(),
        };
        Ok(ast::Function { prototype: function_prototype, body: expression })
    }

    /// Parses a function call expression, like `add(2, 3)`.
    fn parse_function_call(&mut self, name: PositionRangeContainer<String>) -> ParseResult<ast::FunctionCall> {
        // Check and consume opening parentheses
        assert_eq!(self.tokens.next().map(|token| token.data), Some(TokenKind::OpeningParentheses));
        let args = self.parse_argument_list()?;
        // Check and consume closing parentheses
        assert_eq!(self.tokens.next().map(|token| token.data), Some(TokenKind::ClosingParentheses));
        Ok(ast::FunctionCall { name, args })
    }

    /// Parses an identifier. The output is either a [ast::Expression::FunctionCall] or an [ast::Expression::Variable].
    fn parse_identifier_expression(&mut self) -> ParseResult<ast::Expression> {
        let identifier = match self.tokens.next() {
            Some(Token{ data: TokenKind::Identifier(identifier), position}) => {
                PositionRangeContainer { data: identifier, position: position.into() }
            },
            _ => panic!("parse_identifier_expression() called on non-identifier")
        };
        match self.tokens.peek() {
            Some(Token { data: TokenKind::OpeningParentheses, .. }) => {
                // Identifier is followed by an opening parentheses, so it must be a function call
                let function_call = self.parse_function_call(identifier)?;
                Ok(ast::Expression::FunctionCall(function_call))
            }
            _ => {
                // Identifier is followed by something else, so it is a variable
                let variable = self.parse_variable(identifier)?;
                Ok(ast::Expression::Variable(variable))
            },
        }
    }

    /// The most basic type of an expression. Primary expression are either of type identifier, number or parentheses.
    fn parse_primary_expression(&mut self) -> ParseResult<ast::Expression> {
        let token = self.tokens.peek().ok_or(FTLError {
            kind: FTLErrorKind::ExpectedExpression,
            msg: format!("Tried parsing a primary expression, but no expression found"),
            position: self.current_position()
        })?;
        match token {
            Token { data: TokenKind::Identifier(_), .. } => {
                let identifier_expression = self.parse_identifier_expression()?;
                Ok(identifier_expression)
            }
            Token { data: TokenKind::Number(_), .. } => {
                let number = self.parse_number()?;
                Ok(ast::Expression::Number(number))
            }
            Token { data: TokenKind::OpeningParentheses, .. } => {
                let binary_expression = self.parse_parentheses()?;
                Ok(ast::Expression::BinaryExpression(binary_expression))
            },
            _ => return Err(FTLError {
                kind: FTLErrorKind::ExpectedExpression,
                msg: format!("Expected primary expression, got {:?} instead", self.current_token),
                position: self.current_position(),
            }),
        };
        todo!()
    }
}

impl<L: Iterator<Item=Token>> Iterator for Parser<L> {
    type Item = ParseResult<ast::AstNode>;

    fn next(&mut self) -> Option<Self::Item> {
        let token = match &self.get_next_token() {
            Ok(None) => return None, // Lexer drained
            Ok(Some(tok)) => tok,
            Err(err) => return Some(Err(err.clone())),
        };
        match token {
            Token{data: TokenKind::Def, .. } => Some(self.parse_function_definition()),
            Token{data: TokenKind::Extern, .. } => Some(self.parse_extern_function()),
            Token{data: TokenKind::Semicolon, .. } => {
                // No_op (No operation)
                self.get_next_token();
                self.next()
            },
            _ => Some(self.parse_top_level_expression()),
        }
    }
}