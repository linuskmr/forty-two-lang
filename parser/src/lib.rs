//! The parser parses the tokens created by the lexer and and builds an abstract syntax tree
//! from them.

use std::io;

use lexer::{Lexer, Token, TokenType};

/// A parser of tokens generated by its [Lexer].
struct Parser<R: io::Read> {
    /// The [Lexer] to read the [Token]s from.
    lexer: Lexer<R>,
    /// The current token of the parser.
    current_token: Option<Token>,
}

/// The result of a parsing method.
type ParseResult = Result<Box<dyn ast::AST>, String>;

impl<R: io::Read> Parser<R> {
    /// Creates a new Parser with the lexer.
    fn new(lexer: Lexer<R>) -> Self {
        Self {
            lexer,
            current_token: None,
        }
    }

    /// Reads the next token from self.lexer, writes it into self.current_token and returns it.
    fn get_next_token(&mut self) -> &Option<Token> {
        self.current_token = self.lexer.next();
        &self.current_token
    }

    fn parse_expression(&mut self) -> ParseResult {
        todo!()
    }

    /// Parses a number.
    fn parse_number(&mut self, number: f64) -> ParseResult {
        Ok(Box::new(ast::Number(number)))
    }

    /// Parses a parentheses expression, like `3 * (4 + 5)`.
    fn parse_parentheses(&mut self) -> ParseResult {
        self.get_next_token(); // Eat (
        let inner_expression = self.parse_expression()?;
        if let Some(Token { token_type: TokenType::Other(')'), .. }) = self.current_token {
            return Err(format!("Expected `)`"));
        }
        self.get_next_token(); // Eat )
        return Ok(inner_expression);
    }

    /// Parses a variable.
    fn parse_variable(&mut self, variable_name: String) -> ParseResult {
        Ok(Box::new(ast::Variable(variable_name)))
    }

    /// Collects the arguments of a function call, like `add(arg1, arg2)`.
    fn collect_function_call_arguments(&mut self) -> Result<Vec<Box<dyn ast::AST>>, String> {
        if let Some(Token { token_type: TokenType::Other(')'), .. }) = self.current_token {
            // No arguments were passed
            return Ok(Vec::new());
        }
        let mut args = Vec::new();
        loop {
            args.push(self.parse_expression()?);
            match self.current_token {
                Some(Token { token_type: TokenType::Other(')'), .. }) => {
                    // End of argument list
                    break;
                }
                Some(Token { token_type: TokenType::Other(','), .. }) => {
                    // Ok, the argument list keeps going
                    ()
                }
                _ => {
                    // Illegal token
                    return Err(format!("Expected `)` or `,` in argument list"));
                }
            };
        }
        Ok(args)
    }

    /// Parses a function call expression, like `add(2, 3)`.
    fn parse_function_call(&mut self, function_name: String) -> ParseResult {
        self.get_next_token(); // Eat (
        let args = self.collect_function_call_arguments()?;
        self.get_next_token(); // Eat )
        Ok(Box::new(ast::FunctionCall { function_name, args }))
    }

    /// Parses an identifier. The output is either a [ast::FunctionCall] or an [ast::Variable].
    fn parse_identifier(&mut self, identifier: String) -> ParseResult {
        match self.get_next_token().as_ref().unwrap() { // TODO: Error handling
            Token { token_type: TokenType::Other('('), .. } => {
                self.parse_function_call(identifier)
            }
            _ => self.parse_variable(identifier)
        }
    }

    /// TODO: Why is this called *primary*?
    /// Primary expression are either of type identifier, number or parentheses.
    fn parse_primary_expression(&mut self) -> ParseResult {
        match &self.current_token {
            Some(Token { token_type: TokenType::Identifier(identifier), .. }) => {
                self.parse_identifier(identifier.clone()) // TODO: Avoid cloning?
            }
            Some(Token { token_type: TokenType::Number(number), .. }) => {
                self.parse_number(*number)
            }
            Some(Token { token_type: TokenType::Other('(') }) => {
                self.parse_parentheses()
            }
            _ => Err(format!("Expected expression")),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let code = "abc +12.3 -4 def";
        let code = code.as_bytes();
        let _l = Lexer::new(code);
    }
}