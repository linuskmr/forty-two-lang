//! The parser parses the tokens created by the lexer and and builds an abstract syntax tree
//! from them.

use std::io;

use phf::{phf_map, phf_set};

use ast::AST;
use lexer::{Lexer, Token, TokenType};

/// A parser of tokens generated by its [Lexer].
struct Parser<R: io::Read> {
    /// The [Lexer] to read the [Token]s from.
    lexer: Lexer<R>,
    /// The current token of the parser.
    current_token: Option<Token>,
}

/// A number indicating which precedence a token has over others.
type Precedence = u8;

/// The result of a parsing method.
type ParseResult = Result<Box<dyn ast::AST>, String>;

impl<R: io::Read> Parser<R> {
    /// Creates a new Parser with the lexer.
    fn new(lexer: Lexer<R>) -> Self {
        Self {
            lexer,
            current_token: None,
        }
    }

    /// Reads the next token from self.lexer, writes it into self.current_token and returns it.
    fn get_next_token(&mut self) -> &Option<Token> {
        self.current_token = self.lexer.next();
        &self.current_token
    }

    /// Parses a primary expression, potentially followed by a sequence
    /// of (binary operation, primary expression).
    ///
    /// Note: Parentheses are a primary expression, so we don't have to worry about them here.
    fn parse_expression(&mut self) -> ParseResult {
        let lhs = self.parse_primary_expression()?;
        self.parse_binary_operation_rhs(Precedence::default(), lhs)
    }

    /// Parses a sequence of (binary operation, primary expression).
    ///
    /// This function does not consume tokens if the precedence of the current binary operation
    /// is less than `expression_precedence`.
    ///
    /// If this sequence is empty, it returns the lhs. An example of such a binary operation is `x`.
    fn parse_binary_operation_rhs(&mut self, expression_precedence: Precedence, lhs: Box<dyn AST>) -> ParseResult {
        let mut lhs = lhs;
        loop {
            let operation = match self.current_token {
                Some(Token { token_type: Other(operator) }) => operator,
                _ => return {
                    // Current token is not a known binary operation
                    Ok(lhs)
                },
            };
            let token_precedence = match get_token_precedence(operation) {
                None => {
                    // Current token is not a known binary operation
                    return Ok(lhs);
                }
                Some(precedence) if precedence < expression_precedence => {
                    // lhs binds less than the current binary operation
                    return Ok(lhs);
                }
                Some(precedence) => precedence,
            };

            self.get_next_token();

            // Parse the primary expression after the binary operator
            let rhs = self.parse_primary_expression()?;
            match get_token_precedence(&rhs) {
                Some(next_precedence) if token_precedence < next_precedence => {
                    // If the binary operation binds less with rhs than the operator after rhs,
                    // let the next operator take rhs as its lhs.
                    todo!()
                }
                _ => ()
            };

            // Merge lhs and rhs
            return Ok(Box::new(ast::BinaryExpression {
                lhs,
                operation,
                rhs,
            }));
        }
    }

    /// Parses a number.
    fn parse_number(&mut self, number: f64) -> ParseResult {
        Ok(Box::new(ast::Number(number)))
    }

    /// Parses a parentheses expression, like `3 * (4 + 5)`.
    fn parse_parentheses(&mut self) -> ParseResult {
        self.get_next_token(); // Eat (
        let inner_expression = self.parse_expression()?;
        if let Some(Token { token_type: TokenType::Other(')'), .. }) = self.current_token {
            return Err(format!("Expected `)`"));
        }
        self.get_next_token(); // Eat )
        return Ok(inner_expression);
    }

    /// Parses a variable.
    fn parse_variable(&mut self, variable_name: String) -> ParseResult {
        Ok(Box::new(ast::Variable(variable_name)))
    }

    /// Collects the arguments of a function call, like `add(arg1, arg2)`.
    fn collect_function_call_arguments(&mut self) -> Result<Vec<Box<dyn ast::AST>>, String> {
        if let Some(Token { token_type: TokenType::Other(')'), .. }) = self.current_token {
            // No arguments were passed
            return Ok(Vec::new());
        }
        let mut args = Vec::new();
        loop {
            args.push(self.parse_expression()?);
            match self.current_token {
                Some(Token { token_type: TokenType::Other(')'), .. }) => {
                    // End of argument list
                    break;
                }
                Some(Token { token_type: TokenType::Other(','), .. }) => {
                    // Ok, the argument list keeps going
                    ()
                }
                _ => {
                    // Illegal token
                    return Err(format!("Expected `)` or `,` in argument list"));
                }
            };
        }
        Ok(args)
    }

    /// Parses a function call expression, like `add(2, 3)`.
    fn parse_function_call(&mut self, function_name: String) -> ParseResult {
        self.get_next_token(); // Eat (
        let args = self.collect_function_call_arguments()?;
        self.get_next_token(); // Eat )
        Ok(Box::new(ast::FunctionCall { function_name, args }))
    }

    /// Parses an identifier. The output is either a [ast::FunctionCall] or an [ast::Variable].
    fn parse_identifier(&mut self, identifier: String) -> ParseResult {
        match self.get_next_token().as_ref().unwrap() { // TODO: Error handling
            Token { token_type: TokenType::Other('('), .. } => {
                self.parse_function_call(identifier)
            }
            _ => self.parse_variable(identifier)
        }
    }

    /// TODO: Why is this called *primary*?
    /// Primary expression are either of type identifier, number or parentheses.
    fn parse_primary_expression(&mut self) -> ParseResult {
        match &self.current_token {
            Some(Token { token_type: TokenType::Identifier(identifier), .. }) => {
                self.parse_identifier(identifier.clone()) // TODO: Avoid cloning?
            }
            Some(Token { token_type: TokenType::Number(number), .. }) => {
                self.parse_number(*number)
            }
            Some(Token { token_type: TokenType::Other('(') }) => {
                self.parse_parentheses()
            }
            _ => Err(format!("Expected expression")),
        }
    }
}

static BINARY_OPERATION_PRECEDENCE: phf::Map<char, Precedence> = phf_map! {
    '<' => 10,
    '+' => 20,
    '-' => 20,
    '*' => 40,
};

fn get_token_precedence(token: &Token) -> Option<Precedence> {
    match token {
        Token { token_type: TokenType::Other(character) } => {
            BINARY_OPERATION_PRECEDENCE.get(&character).cloned()
        }
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let code = "abc +12.3 -4 def";
        let code = code.as_bytes();
        let _l = Lexer::new(code);
    }
}